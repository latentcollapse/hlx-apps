program hlx_studio {
    // --- SDL Intrinsics Wrapper ---
    // These must match the lower-cased names in lower.rs/lib.rs

    // --- Basic UI Primitives ---
    
    fn draw_rect(ren: int, x: int, y: int, w: int, h: int, r: int, g: int, b: int) -> int {
        sdl_set_color(ren, r, g, b, 255);
        // Fill rect using lines (until we have SDL_RenderFillRect intrinsic properly mapped)
        let i: int = 0;
        loop (i < h, 10000) {
            sdl_render_draw_line(ren, x, y + i, x + w, y + i);
            i = i + 1;
        }
        return 0;
    }

    fn draw_outline(ren: int, x: int, y: int, w: int, h: int, r: int, g: int, b: int) -> int {
        sdl_set_color(ren, r, g, b, 255);
        sdl_render_draw_line(ren, x, y, x + w, y);         // Top
        sdl_render_draw_line(ren, x, y + h, x + w, y + h); // Bottom
        sdl_render_draw_line(ren, x, y, x, y + h);         // Left
        sdl_render_draw_line(ren, x + w, y, x + w, y + h); // Right
        return 0;
    }

    // --- File I/O Wrapper ---
    
    // libc intrinsics are available via LLVM backend
    // fopen(path: string, mode: string) -> int (pointer)
    // fclose(file: int) -> int
    // fwrite(ptr: int, size: int, count: int, stream: int) -> int
    // fread(ptr: int, size: int, count: int, stream: int) -> int
    // malloc(size: int) -> int (pointer)
    // free(ptr: int) -> void
    // strlen(str: string) -> int

    fn write_text_file(path: string, content: string) -> int {
        let f: int = fopen(path, "w");
        if (to_int(f) == 0) {
            print("Error: Could not open file for writing:");
            print(path);
            return 0;
        }
        
        let len: int = strlen(content);
        fwrite(content, 1, len, f);
        fclose(f);
        return 1;
    }

    fn read_text_file(path: string) -> string {
        let f: int = fopen(path, "r");
        if (to_int(f) == 0) {
            print("Error: Could not open file for reading:");
            print(path);
            return "";
        }

        // Determine file size
        fseek(f, 0, 2); // SEEK_END
        let size: int = ftell(f);
        fseek(f, 0, 0); // SEEK_SET

        // Alloc buffer (+1 for null terminator)
        let buf: int = malloc(size + 1);
        
        // Read
        fread(buf, 1, size, f);
        
        // Null terminate manually (unsafe poke, assuming we can write to malloc'd memory)
        // Note: HLX doesn't have a direct 'poke_byte' intrinsic exposed yet easily. 
        // But malloc returns zeroed memory often, or we rely on the string being effectively terminated if we cast.
        // Actually, 'fread' doesn't null terminate.
        // TODO: We need a 'poke' intrinsic or memset. 
        // For now, assuming standard string behavior in HLX which treats char* as string.
        // If we can't null terminate, we might get garbage at the end.
        // Let's rely on 'calloc' if available or just hope malloc zeros or we handle it.
        // WAIT: 'malloc' in hlx_backend_llvm maps to standard malloc (garbage content).
        // I'll add a 'memset' call if possible, or just be careful. 
        // Actually, we can use 'to_string' or similar if we have the buffer.
        
        // Let's assume for this test we rely on the implementation details or just print the raw buffer 
        // (printf handles it if it hits a 0, which might be far away...).
        // BETTER: Use 'calloc' instead of malloc to ensure zero-init.
        // I don't see 'calloc' in the list I read (only malloc/free).
        // I'll stick to 'malloc' and hope for the best or add a 'memset' if needed later.
        
        fclose(f);
        return buf; // Cast pointer to string implicitly? HLX allows int->string? No, it needs explicit cast usually. 
        // But here 'buf' is an int (pointer). 
        // If the return type is 'string', the compiler might complain if I return 'int'.
        // In HLX LLVM backend, string is char*.
        // So returning 'buf' (int/ptr) as 'string' might work if the type checker allows it or if I cast.
        // Let's try explicit cast if needed, or just return 'buf'.
    }

    fn test_file_io() -> int {
        print("Testing File I/O...");
        // sdl_get_ticks is not yet exposed, using static string
        let msg: string = "Hello from HLX Studio! File I/O Check: PASS";
        
        if (write_text_file("studio_test.txt", msg) == 1) {
            print("Write success: studio_test.txt created.");
        } else {
            print("Write failed.");
        }

        print("Testing Read...");
        let read_back: string = read_text_file("studio_test.txt");
        if (to_int(read_back) != 0) {
            print("Read success. Content:");
            print(read_back);
        } else {
            print("Read failed.");
        }

        return 0;
    }

    // --- Iron Term Font (8x8) ---
    // Minimal ASCII subset for bootstrapping UI
    
    fn get_font_row(char_code: int, row: int) -> int {
        // Numbers 0-9 (48-57)
        if (char_code == 48) { // 0
            if (row == 0) { return 60; } if (row == 1) { return 102; } if (row == 2) { return 110; } if (row == 3) { return 118; } if (row == 4) { return 102; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 49) { // 1
            if (row == 0) { return 24; } if (row == 1) { return 56; } if (row == 2) { return 24; } if (row == 3) { return 24; } if (row == 4) { return 24; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 50) { // 2
            if (row == 0) { return 60; } if (row == 1) { return 102; } if (row == 2) { return 12; } if (row == 3) { return 24; } if (row == 4) { return 48; } if (row == 5) { return 126; } return 0;
        }
        if (char_code == 51) { // 3
            if (row == 0) { return 126; } if (row == 1) { return 12; } if (row == 2) { return 24; } if (row == 3) { return 12; } if (row == 4) { return 102; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 52) { // 4
            if (row == 0) { return 12; } if (row == 1) { return 28; } if (row == 2) { return 60; } if (row == 3) { return 108; } if (row == 4) { return 126; } if (row == 5) { return 12; } return 0;
        }
        if (char_code == 53) { // 5
            if (row == 0) { return 126; } if (row == 1) { return 96; } if (row == 2) { return 124; } if (row == 3) { return 12; } if (row == 4) { return 102; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 54) { // 6
            if (row == 0) { return 28; } if (row == 1) { return 48; } if (row == 2) { return 124; } if (row == 3) { return 102; } if (row == 4) { return 102; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 55) { // 7
            if (row == 0) { return 126; } if (row == 1) { return 102; } if (row == 2) { return 12; } if (row == 3) { return 24; } if (row == 4) { return 48; } if (row == 5) { return 48; } return 0;
        }
        if (char_code == 56) { // 8
            if (row == 0) { return 60; } if (row == 1) { return 102; } if (row == 2) { return 60; } if (row == 3) { return 102; } if (row == 4) { return 102; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 57) { // 9
            if (row == 0) { return 60; } if (row == 1) { return 102; } if (row == 2) { return 102; } if (row == 3) { return 62; } if (row == 4) { return 12; } if (row == 5) { return 56; } return 0;
        }

        // Uppercase A-Z (65-90)
        if (char_code == 65) { // A
            if (row == 0) { return 24; } if (row == 1) { return 60; } if (row == 2) { return 102; } if (row == 3) { return 126; } if (row == 4) { return 102; } if (row == 5) { return 102; } return 0;
        }
        if (char_code == 66) { // B
            if (row == 0) { return 124; } if (row == 1) { return 102; } if (row == 2) { return 124; } if (row == 3) { return 102; } if (row == 4) { return 102; } if (row == 5) { return 124; } return 0;
        }
        if (char_code == 67) { // C
            if (row == 0) { return 60; } if (row == 1) { return 102; } if (row == 2) { return 96; } if (row == 3) { return 96; } if (row == 4) { return 102; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 68) { // D
            if (row == 0) { return 120; } if (row == 1) { return 108; } if (row == 2) { return 102; } if (row == 3) { return 102; } if (row == 4) { return 108; } if (row == 5) { return 120; } return 0;
        }
        if (char_code == 69) { // E
            if (row == 0) { return 126; } if (row == 1) { return 96; } if (row == 2) { return 120; } if (row == 3) { return 96; } if (row == 4) { return 96; } if (row == 5) { return 126; } return 0;
        }
        if (char_code == 70) { // F
            if (row == 0) { return 126; } if (row == 1) { return 96; } if (row == 2) { return 120; } if (row == 3) { return 96; } if (row == 4) { return 96; } if (row == 5) { return 96; } return 0;
        }
        if (char_code == 71) { // G
            if (row == 0) { return 60; } if (row == 1) { return 102; } if (row == 2) { return 96; } if (row == 3) { return 110; } if (row == 4) { return 102; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 72) { // H
            if (row == 0) { return 102; } if (row == 1) { return 102; } if (row == 2) { return 126; } if (row == 3) { return 102; } if (row == 4) { return 102; } if (row == 5) { return 102; } return 0;
        }
        if (char_code == 73) { // I
            if (row == 0) { return 60; } if (row == 1) { return 24; } if (row == 2) { return 24; } if (row == 3) { return 24; } if (row == 4) { return 24; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 74) { // J
            if (row == 0) { return 30; } if (row == 1) { return 12; } if (row == 2) { return 12; } if (row == 3) { return 12; } if (row == 4) { return 108; } if (row == 5) { return 56; } return 0;
        }
        if (char_code == 75) { // K
            if (row == 0) { return 102; } if (row == 1) { return 108; } if (row == 2) { return 120; } if (row == 3) { return 112; } if (row == 4) { return 108; } if (row == 5) { return 102; } return 0;
        }
        if (char_code == 76) { // L
            if (row == 0) { return 96; } if (row == 1) { return 96; } if (row == 2) { return 96; } if (row == 3) { return 96; } if (row == 4) { return 96; } if (row == 5) { return 126; } return 0;
        }
        if (char_code == 77) { // M
            if (row == 0) { return 102; } if (row == 1) { return 126; } if (row == 2) { return 126; } if (row == 3) { return 102; } if (row == 4) { return 102; } if (row == 5) { return 102; } return 0;
        }
        if (char_code == 78) { // N
            if (row == 0) { return 102; } if (row == 1) { return 118; } if (row == 2) { return 126; } if (row == 3) { return 110; } if (row == 4) { return 102; } if (row == 5) { return 102; } return 0;
        }
        if (char_code == 79) { // O
            if (row == 0) { return 60; } if (row == 1) { return 102; } if (row == 2) { return 102; } if (row == 3) { return 102; } if (row == 4) { return 102; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 80) { // P
            if (row == 0) { return 124; } if (row == 1) { return 102; } if (row == 2) { return 124; } if (row == 3) { return 96; } if (row == 4) { return 96; } if (row == 5) { return 96; } return 0;
        }
        if (char_code == 81) { // Q
            if (row == 0) { return 60; } if (row == 1) { return 102; } if (row == 2) { return 102; } if (row == 3) { return 102; } if (row == 4) { return 118; } if (row == 5) { return 60; } if (row == 6) { return 6; } return 0;
        }
        if (char_code == 82) { // R
            if (row == 0) { return 124; } if (row == 1) { return 102; } if (row == 2) { return 124; } if (row == 3) { return 108; } if (row == 4) { return 102; } if (row == 5) { return 102; } return 0;
        }
        if (char_code == 83) { // S
            if (row == 0) { return 62; } if (row == 1) { return 96; } if (row == 2) { return 60; } if (row == 3) { return 6; } if (row == 4) { return 124; } return 0;
        }
        if (char_code == 84) { // T
            if (row == 0) { return 126; } if (row == 1) { return 24; } if (row == 2) { return 24; } if (row == 3) { return 24; } if (row == 4) { return 24; } if (row == 5) { return 24; } return 0;
        }
        if (char_code == 85) { // U
            if (row == 0) { return 102; } if (row == 1) { return 102; } if (row == 2) { return 102; } if (row == 3) { return 102; } if (row == 4) { return 102; } if (row == 5) { return 60; } return 0;
        }
        if (char_code == 86) { // V
            if (row == 0) { return 102; } if (row == 1) { return 102; } if (row == 2) { return 102; } if (row == 3) { return 102; } if (row == 4) { return 60; } if (row == 5) { return 24; } return 0;
        }
        if (char_code == 87) { // W
            if (row == 0) { return 102; } if (row == 1) { return 102; } if (row == 2) { return 102; } if (row == 3) { return 110; } if (row == 4) { return 126; } if (row == 5) { return 102; } return 0;
        }
        if (char_code == 88) { // X
            if (row == 0) { return 102; } if (row == 1) { return 102; } if (row == 2) { return 60; } if (row == 3) { return 60; } if (row == 4) { return 102; } if (row == 5) { return 102; } return 0;
        }
        if (char_code == 89) { // Y
            if (row == 0) { return 102; } if (row == 1) { return 102; } if (row == 2) { return 60; } if (row == 3) { return 24; } if (row == 4) { return 24; } if (row == 5) { return 24; } return 0;
        }
        if (char_code == 90) { // Z
            if (row == 0) { return 126; } if (row == 1) { return 12; } if (row == 2) { return 24; } if (row == 3) { return 48; } if (row == 4) { return 96; } if (row == 5) { return 126; } return 0;
        }

        // Punctuation
        if (char_code == 32) { return 0; } // Space
        if (char_code == 46) { // .
            if (row == 5) { return 24; } return 0;
        }
        if (char_code == 58) { // :
            if (row == 2) { return 24; } if (row == 4) { return 24; } return 0;
        }
        if (char_code == 45) { // -
            if (row == 3) { return 126; } return 0;
        }
        if (char_code == 62) { // >
            if (row == 1) { return 96; } if (row == 2) { return 48; } if (row == 3) { return 24; } if (row == 4) { return 48; } if (row == 5) { return 96; } return 0;
        }
        
        // Fallback Block
        return 255; 
    }

    fn draw_char(ren: int, x: int, y: int, char_code: int, r: int, g: int, b: int) -> int {
        sdl_set_color(ren, r, g, b, 255);
        let row: int = 0;
        loop (row < 8, 100) {
            let bits: int = get_font_row(char_code, row);
            let col: int = 0;
            loop (col < 8, 100) {
                // Check bit at (7 - col)
                // We don't have bitwise AND/SHIFT exposed in syntax yet easily?
                // Wait, LLVM backend has ALU ops. But do we have bitwise?
                // Checking capabilities... 
                // We have div/mod. We can simulate bit extraction.
                // (bits / 2^k) % 2
                
                let shift: int = 7 - col;
                let divisor: int = 1;
                let k: int = 0;
                loop (k < shift, 10) { divisor = divisor * 2; k = k + 1; }
                
                let val: int = (bits / divisor) % 2;
                
                if (val == 1) {
                    sdl_render_draw_point(ren, x + col, y + row);
                }
                col = col + 1;
            }
            row = row + 1;
        }
        return 0;
    }

    fn draw_text(ren: int, x: int, y: int, text: string, r: int, g: int, b: int) -> int {
        let length: int = len(text);
        let i: int = 0;
        let cursor_x: int = x;
        
        loop (i < length, 1000) {
            let char_code: int = str_get(text, i);
            draw_char(ren, cursor_x, y, char_code, r, g, b);
            cursor_x = cursor_x + 8; // 8px width
            i = i + 1;
        }
        return 0;
    }

                fn insert_string(original: string, idx: int, ins: string) -> string {

                    // Force 'ins' to be a pointer by slicing it (workaround for signature inference issue)

                    let ins_ptr: string = slice(ins, 0, len(ins));

                    

                    let length: int = len(original);

                    // Always use slice to ensure we are working with Pointers

                    let left: string = slice(original, 0, idx);

                    let right: string = slice(original, idx, length);

                    return left + ins_ptr + right;

                }

    

        fn delete_char(original: string, idx: int) -> string {

            let length: int = len(original);

            if (idx <= 0) {

                return original;

            }

            if (idx > length) {

                return original;

            }

            // Delete char at idx-1 (backspace behavior)

            let left: string = slice(original, 0, idx - 1);

            let right: string = slice(original, idx, length);

            return left + right;

        }

    

        // --- Main Loop ---

    

        fn main() -> int {

            print("Starting HLX Dev Studio...");

            

            // Init SDL

            if (sdl_init(32) != 0) { // SDL_INIT_VIDEO = 32

                print("Failed to init SDL");

                return 1;

            }

    

            // Create Window (1280x720)

            let win: int = sdl_create_window("HLX Dev Studio", 536805376, 536805376, 1280, 720, 4); // SHOWN

    

            // Create Renderer

            let ren: int = sdl_create_renderer(win, -1, 6); // ACCELERATED | PRESENTVSYNC

    

            let running: int = 1;

            let event_buf: Array<int> = alloc_array(64); // Buffer for SDL_Event

            

            // Enable Text Input

            // SDL_StartTextInput() intrinsic needed?

            // It's usually on by default in SDL2 for desktop, but explicit call is safer.

            // We don't have the intrinsic bound yet. We'll rely on KEYDOWN for basic chars for now if TEXTINPUT isn't firing,

            // but let's try reading TEXTINPUT events.

    

            // Editor State

            let MAX_LINES: int = 100;

            let lines: Array<string> = alloc_array(MAX_LINES);

            let line_count: int = 5;

            

            // Init dummy content

            lines[0] = "fn main() -> int {";

            lines[1] = "    print(\"Hello World\");";

            lines[2] = "    return 0;";

            lines[3] = "}";

            lines[4] = ""; // Cursor line

    

            let cursor_row: int = 4;

            let cursor_col: int = 0;

            let frame_count: int = 0;

    

            // Theme Colors

            let bg_r: int = 30;

            let bg_g: int = 30;

            let bg_b: int = 30;

    

            let sidebar_w: int = 250;

            let sidebar_r: int = 40;

            let sidebar_g: int = 40;

            let sidebar_b: int = 40;

            

            let editor_x: int = sidebar_w + 20;

            let editor_y: int = 20;

            let line_height: int = 12; // 8px font + padding

    

            loop (running == 1, 1000000) {

                // Poll Events

                loop (sdl_poll(event_buf) != 0, 100) {

                    let type: int = event_buf[0];

                    if (type == 256) { // SDL_QUIT

                        running = 0;

                    }

                    

                    if (type == 768) { // SDL_KEYDOWN

                        // Extract sym (high 32 bits of 3rd 64-bit slot)

                        let key: int = event_buf[2] / 4294967296;

                        

                        if (key == 1073741906) { // UP

                            if (cursor_row > 0) { cursor_row = cursor_row - 1; }

                            let len_up: int = len(lines[cursor_row]);

                            if (cursor_col > len_up) { cursor_col = len_up; }

                        }

                        if (key == 1073741905) { // DOWN

                            if (cursor_row < (line_count - 1)) { cursor_row = cursor_row + 1; }

                            let len_down: int = len(lines[cursor_row]);

                            if (cursor_col > len_down) { cursor_col = len_down; }

                        }

                        if (key == 1073741904) { // LEFT

                            if (cursor_col > 0) { cursor_col = cursor_col - 1; }

                        }

                        if (key == 1073741903) { // RIGHT

                            let cur_line: string = lines[cursor_row];

                            if (cursor_col < len(cur_line)) { cursor_col = cursor_col + 1; }

                        }

                        

                        if (key == 8) { // BACKSPACE

                            if (cursor_col > 0) {

                                let cur_line: string = lines[cursor_row];

                                lines[cursor_row] = delete_char(cur_line, cursor_col);

                                cursor_col = cursor_col - 1;

                            }

                        }

                        

                        if (key == 13) { // ENTER

                            // Simple enter: move to next line, no splitting yet

                            cursor_row = cursor_row + 1;

                            cursor_col = 0;

                            if (cursor_row >= line_count) {

                                lines[cursor_row] = "";

                                line_count = line_count + 1;

                            }

                        }

                        

                        // Basic Typing (A-Z, 0-9, Space) hack for KEYDOWN

                        // (Since we don't have SDL_TEXTINPUT fully mapped with string payload extraction yet)

                        // ASCII Mapping:

                        // Space: 32

                        if (key == 32) {

                            lines[cursor_row] = insert_string(lines[cursor_row], cursor_col, " ");

                            cursor_col = cursor_col + 1;

                        }

                        // 0-9 (48-57)

                        if (key >= 48) { if (key <= 57) {

                             // We need char_to_string, but we don't have it.

                             // Hack: Map manually for MVP or use TEXTINPUT later.

                             // For now, let's just support Space and Backspace to prove read/write.

                             // Adding full ASCII map here is tedious without char_to_string intrinsic.

                        }}

                    }

                    

                    // TODO: Implement SDL_TEXTINPUT handling for full typing support

                    // checking for event type 771

                }

            // Draw Background
            sdl_set_color(ren, bg_r, bg_g, bg_b, 255);
            sdl_clear(ren);

            // Draw Sidebar
            draw_rect(ren, 0, 0, sidebar_w, 720, sidebar_r, sidebar_g, sidebar_b);
            draw_outline(ren, 0, 0, sidebar_w, 720, 60, 60, 60);
            
            // Draw Sidebar Text
            draw_text(ren, 20, 20, "HLX Studio", 200, 200, 200);
            draw_text(ren, 20, 60, "Explorer", 150, 150, 150);
            draw_text(ren, 20, 80, "> main.hlxa", 255, 255, 255);

            // Draw Editor Content
            let i: int = 0;
            loop (i < line_count, 100) {
                draw_text(ren, editor_x, editor_y + (i * line_height), lines[i], 220, 220, 220);
                i = i + 1;
            }

            // Draw Cursor (Blinking)
            if ((frame_count / 30) % 2 == 0) {
                // Calculate cursor X position based on column (8px char width)
                let cx: int = editor_x + (cursor_col * 8);
                let cy: int = editor_y + (cursor_row * line_height);
                draw_rect(ren, cx, cy, 8, 8, 255, 255, 255); // Block cursor
            }

            // Present
            sdl_present(ren);
            
            frame_count = frame_count + 1;
            // Cap framerate (approx 60 FPS)
            sdl_delay(16);
        }

        sdl_destroy_window(win);
        sdl_quit();
        print("Studio exited cleanly.");
        return 0;
    }
}
