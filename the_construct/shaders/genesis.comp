#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, std430) buffer Output {
    int data[];
};

layout(push_constant) uniform Constants {
    uint time_ms;
    uint width;    
    uint height;
} params;

// --- UTILS ---
float hash(float n) { return fract(sin(n) * 43758.5453123); }
float noise(vec3 x) {
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
    float n = p.x + p.y*57.0 + 113.0*p.z;
    return mix(mix(mix(hash(n+0.0), hash(n+1.0),f.x),
                   mix(hash(n+57.0), hash(n+58.0),f.x),f.y),
               mix(mix(hash(n+113.0), hash(n+114.0),f.x),
                   mix(hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
}

mat2 rot2D(float a) {
    float s = sin(a), c = cos(a);
    return mat2(c, -s, s, c);
}

// --- SDFs ---

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

// Corrected Arch Logo SDF (Upright)
float sdArchLogo(vec3 p) {
    p.y -= 1.0; // Offset for centering
    
    // The main triangle shape
    float d = max(abs(p.x)*0.8 - p.y*0.5, p.y - 2.0); 
    
    // The bottom curve cutout
    float curve = length(p.xy - vec2(0.0, -1.8)) - 2.2;
    d = max(d, -curve);
    
    // The center "A" bridge hole
    float hole = length(p.xy - vec2(0.0, 0.4)) - 0.35;
    d = max(d, -hole);

    return d;
}

float map(vec3 p) {
    float time = float(params.time_ms) / 1000.0;
    
    // 1. THE MONOLITH (Upright & Hovering)
    vec3 pM = p - vec3(0.0, 1.0 + sin(time*0.5)*0.3, 5.0);
    pM.xz *= rot2D(time * 0.15);
    float dMonolith = max(sdArchLogo(pM), abs(pM.z) - 0.3);
    
    // 2. THE REPO CITY (On the ground where it belongs)
    vec3 pF = p;
    pF.y += 4.0; // Floor at y = -4
    vec2 id = floor(pF.xz / 2.0);
    vec3 pQ = pF;
    pQ.xz = mod(pQ.xz, 2.0) - 1.0;
    float h = hash(id.x * 133.0 + id.y * 77.0) * 3.5;
    float dFloor = sdBox(pQ, vec3(0.7, h, 0.7));
    
    // 3. FLOATING DATA BITS
    vec3 pS = p;
    pS.y -= 5.0 + sin(time) * 2.0;
    pS.xz *= rot2D(time * 0.4);
    pS.xz = mod(pS.xz + time, 8.0) - 4.0;
    float dSwarm = length(pS) - 0.05;

    return min(dMonolith, min(dFloor, dSwarm));
}

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    if (x >= params.width || y >= params.height) return;

    // Correct UV mapping for Vulkan (+Y is down in screen space)
    vec2 uv = (vec2(x, y) - 0.5 * vec2(params.width, params.height)) / float(params.height);
    float time = float(params.time_ms) / 1000.0;

    // Correcting Camera (Looking Upward at the Monolith)
    vec3 ro = vec3(0.0, -1.0, -8.0); 
    vec3 rd = normalize(vec3(uv.x, -uv.y, 1.2)); // Flipped uv.y for upright view
    rd.yz *= rot2D(0.1); 

    // Raymarching
    float d = 0.0, t = 0.0;
    for(int i=0; i<90; i++) {
        d = map(ro + rd * t);
        if(d < 0.001 || t > 50.0) break;
        t += d;
    }

    vec3 col = vec3(0.01, 0.02, 0.01); // Dark green void base
    
    if(t < 50.0) {
        vec3 p = ro + rd * t;
        vec3 n = normalize(vec3(
            map(p+vec3(0.01,0,0)) - map(p-vec3(0.01,0,0)),
            map(p+vec3(0,0.01,0)) - map(p-vec3(0,0.01,0)),
            map(p+vec3(0,0,0.01)) - map(p-vec3(0,0,0.01))
        ));
        
        // Dynamic Glow and Stripe Pattern
        float stripe = smoothstep(0.45, 0.5, sin(p.y * 12.0 - time * 8.0));
        vec3 baseCol = vec3(0.1, 0.3, 0.15); 
        
        // Identify Monolith for extra glow
        float distToMonolith = max(sdArchLogo(p - vec3(0.0, 1.0 + sin(time*0.5)*0.3, 5.0)), 0.0);
        if (distToMonolith < 0.1) {
            baseCol = vec3(0.2, 0.9, 0.4);
        }
        
        col = baseCol * max(dot(n, vec3(0.5, 0.8, -0.5)), 0.2);
        col += stripe * baseCol * 0.4;
        
        // Specular highlight
        vec3 ref = reflect(rd, n);
        col += pow(max(dot(ref, vec3(0,1,0)), 0.0), 16.0) * 0.3;
    }

    // FOG & ATMOSPHERE
    float fog = exp(-t * 0.07);
    vec3 fogCol = vec3(0.01, 0.08, 0.04) * (noise(vec3(uv * 3.0, time * 0.1)) + 0.5);
    col = mix(fogCol, col, fog);
    
    // Core Pulse Glow
    float centerGlow = 1.0 / (1.0 + t*t*0.02);
    col += vec3(0.1, 0.6, 0.3) * centerGlow * (0.5 + 0.5*sin(time*2.0));

    // Post-Process: Data corruption Scanlines
    float scan = sin(uv.y * 600.0 + time * 30.0);
    col *= 0.95 + 0.05 * scan;
    
    // Jitter/Glitch post-process
    if (hash(time) > 0.98) col += 0.1 * noise(vec3(uv * 100.0, time));

    // Output RGBA
    uint outCol = (255 << 24) | 
                  (uint(clamp(col.b, 0.0, 1.0) * 255.0) << 16) | 
                  (uint(clamp(col.g, 0.0, 1.0) * 255.0) << 8) | 
                   uint(clamp(col.r, 0.0, 1.0) * 255.0);

    data[y * params.width + x] = int(outCol);
}
