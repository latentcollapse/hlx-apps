// Software Rasterizer for HLX
// Uses Barycentric coordinates for triangle filling

program rasterizer {

    fn init_buffers(width: int, height: int) -> Array<Array<float>> {
        // We pack everything into a "Context" array because structs aren't fully lowered yet?
        // Actually, let's just return a struct-like array.
        // [0]: Framebuffer (Array<int>) - Wait, return type signature issue.
        // I'll manage buffers globally or pass them explicitly.
        
        // For now, simple factory functions.
        let size: int = width * height;
        let zbuffer: Array<float> = alloc_array(size);
        
        // Initialize Z-buffer to infinity (or big number)
        let i: int = 0;
        loop (i < size, 1000000) {
            zbuffer[i] = 10000.0;
            i = i + 1;
        }
        
        // Wrap in array for return? No, types differ.
        // I'll just return the Z-buffer here.
        return zbuffer;
    }

    fn clear_buffers(pixels: Array<int>, zbuffer: Array<float>, width: int, height: int, color: int) {
        let size: int = width * height;
        let i: int = 0;
        
        // Clear loop
        // Optimization: In native, we could use memset, but loop proves the compiler.
        loop (i < size, 1000000) {
            pixels[i] = color;
            zbuffer[i] = 10000.0;
            i = i + 1;
        }
    }

    // Edge function: (P - A) x (B - A)
    // Returns positive if P is to the right of AB
    fn edge_function(a: Array<float>, b: Array<float>, c: Array<float>) -> float {
        let ax: float = a[0];
        let ay: float = a[1];
        let bx: float = b[0];
        let by: float = b[1];
        let cx: float = c[0];
        let cy: float = c[1];
        
        return ((cx - ax) * (by - ay) - (cy - ay) * (bx - ax));
    }

    fn draw_triangle(
        pixels: Array<int>, zbuffer: Array<float>, w: int, h: int,
        v0: Array<float>, v1: Array<float>, v2: Array<float>,
        color: int
    ) {
        // Bounding box
        let min_x: int = to_int(floor(min3(v0[0], v1[0], v2[0])));
        let min_y: int = to_int(floor(min3(v0[1], v1[1], v2[1])));
        let max_x: int = to_int(ceil(max3(v0[0], v1[0], v2[0])));
        let max_y: int = to_int(ceil(max3(v0[1], v1[1], v2[1])));

        // Clamp to screen
        min_x = max(min_x, 0);
        min_y = max(min_y, 0);
        max_x = min(max_x, w - 1);
        max_y = min(max_y, h - 1);

        // Precompute area (for barycentric normalization)
        let area: float = edge_function(v0, v1, v2);
        
        // If area is 0 or negative (backface), skip
        // Backface culling:
        if (area <= 0.0) { return 0; } // Assuming CCW winding

        let p: Array<float> = [0.0, 0.0];

        // Rasterize
        let y: int = min_y;
        loop (y <= max_y, 2000) {
            let x: int = min_x;
            loop (x <= max_x, 2000) {
                // Pixel center
                p[0] = to_float(x) + 0.5;
                p[1] = to_float(y) + 0.5;
                
                // Barycentric coords
                let w0: float = edge_function(v1, v2, p);
                let w1: float = edge_function(v2, v0, p);
                let w2: float = edge_function(v0, v1, p);
                
                // If inside triangle (all weights positive)
                if (w0 >= 0.0) {
                    if (w1 >= 0.0) {
                        if (w2 >= 0.0) {
                            // Interpolate Z
                            w0 = w0 / area;
                            w1 = w1 / area;
                            w2 = w2 / area;
                            
                            let z: float = (w0 * v0[2]) + (w1 * v1[2]) + (w2 * v2[2]);
                            
                            // Depth test
                            let idx: int = (y * w) + x;
                            if (z < zbuffer[idx]) {
                                zbuffer[idx] = z;
                                pixels[idx] = color;
                            }
                        }
                    }
                }
                x = x + 1;
            }
            y = y + 1;
        }
    }

    // --- MATH HELPERS ---
    
    fn min(a: int, b: int) -> int {
        if (a < b) { return a; } else { return b; }
        return a;
    }
    
    fn max(a: int, b: int) -> int {
        if (a > b) { return a; } else { return b; }
        return a;
    }

    fn min3(a: float, b: float, c: float) -> float {
        let m: float = a;
        if (b < m) { m = b; }
        if (c < m) { m = c; }
        return m;
    }

    fn max3(a: float, b: float, c: float) -> float {
        let m: float = a;
        if (b > m) { m = b; }
        if (c > m) { m = c; }
        return m;
    }
}
