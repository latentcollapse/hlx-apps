program the_construct {
    
    // --- MATH ---
    fn vec3(x: float, y: float, z: float) -> Array<float> {
        let res: Array<float> = [x, y, z];
        return res;
    }

    fn rotate_y(v: Array<float>, angle: float) -> Array<float> {
        let x: float = v[0];
        let y: float = v[1];
        let z: float = v[2];
        let c: float = cos(angle);
        let s: float = sin(angle);
        let nx: float = (x * c) - (z * s);
        let nz: float = (x * s) + (z * c);
        return [nx, y, nz];
    }

    fn rotate_x(v: Array<float>, angle: float) -> Array<float> {
        let x: float = v[0];
        let y: float = v[1];
        let z: float = v[2];
        let c: float = cos(angle);
        let s: float = sin(angle);
        let ny: float = (y * c) - (z * s);
        let nz: float = (y * s) + (z * c);
        return [x, ny, nz];
    }

    fn project_vertex(v: Array<float>, w: int, h: int) -> Array<float> {
        let x: float = v[0];
        let y: float = v[1];
        let z: float = v[2];
        let fov: float = 300.0;
        let dist: float = 3.0;
        let z_shift: float = dist + z;
        let px: float = (x * fov) / z_shift;
        let py: float = (y * fov) / z_shift;
        let cx: float = to_float(w) / 2.0;
        let cy: float = to_float(h) / 2.0;
        return [px + cx, py + cy, z_shift];
    }

    // --- RASTERIZER KERNEL ---
    
    fn edge_function(a: Array<float>, b: Array<float>, c: Array<float>) -> float {
        let ax: float = a[0];
        let ay: float = a[1];
        let bx: float = b[0];
        let by: float = b[1];
        let cx: float = c[0];
        let cy: float = c[1];
        return ((cx - ax) * (by - ay) - (cy - ay) * (bx - ax));
    }

    fn min3(a: float, b: float, c: float) -> float {
        let m: float = a;
        if (b < m) { m = b; }
        if (c < m) { m = c; }
        return m;
    }

    fn max3(a: float, b: float, c: float) -> float {
        let m: float = a;
        if (b > m) { m = b; }
        if (c > m) { m = c; }
        return m;
    }

    fn draw_triangle(
        ren: int, 
        v0: Array<float>, v1: Array<float>, v2: Array<float>,
        r: int, g: int, b: int
    ) -> int {
        let min_xf: float = min3(v0[0], v1[0], v2[0]);
        let min_yf: float = min3(v0[1], v1[1], v2[1]);
        let max_xf: float = max3(v0[0], v1[0], v2[0]);
        let max_yf: float = max3(v0[1], v1[1], v2[1]);

        let min_x: int = to_int(min_xf);
        let min_y: int = to_int(min_yf);
        let max_x: int = to_int(max_xf);
        let max_y: int = to_int(max_yf);

        let w: int = 800;
        let h: int = 600;
        if (min_x < 0) { min_x = 0; }
        if (min_y < 0) { min_y = 0; }
        if (max_x >= w) { max_x = w - 1; }
        if (max_y >= h) { max_y = h - 1; }

        let area: float = edge_function(v0, v1, v2);
        if (area <= 0.0) { return 0; }

        let p: Array<float> = [0.0, 0.0];
        // SDL Draw Calls - Disabled for headless VM test
        // SDL_SetRenderDrawColor(ren, r, g, b, 255);

        let y: int = min_y;
        loop (y <= max_y, 600) {
            let x: int = min_x;
            loop (x <= max_x, 800) {
                p[0] = to_float(x) + 0.5;
                p[1] = to_float(y) + 0.5;
                
                let w0: float = edge_function(v1, v2, p);
                let w1: float = edge_function(v2, v0, p);
                let w2: float = edge_function(v0, v1, p);
                
                if (w0 >= 0.0) {
                    if (w1 >= 0.0) {
                        if (w2 >= 0.0) {
                            // SDL_RenderDrawPoint(ren, x, y);
                        }
                    }
                }
                x = x + 1;
            }
            y = y + 1;
        }
        return 0;
    }

    // --- MAIN ---
    fn main() -> int {
        print("--- The Construct: Phase 4 (Rasterizer - HEADLESS TEST) ---");

        print("Creating vertices...");
        let v0: Array<float> = vec3(-1.0, -1.0, -1.0);
        let v1: Array<float> = vec3(1.0, -1.0, -1.0);
        let v2: Array<float> = vec3(1.0, 1.0, -1.0);
        let v3: Array<float> = vec3(-1.0, 1.0, -1.0);
        let v4: Array<float> = vec3(-1.0, -1.0, 1.0);
        let v5: Array<float> = vec3(1.0, -1.0, 1.0);
        let v6: Array<float> = vec3(1.0, 1.0, 1.0);
        let v7: Array<float> = vec3(-1.0, 1.0, 1.0);
        print("Vertices created.");
        
        let verts: Array<Array<float>> = [v0, v1, v2, v3, v4, v5, v6, v7];
        print("Vertex array created.");

        // Test rotation
        print("Testing rotation...");
        let r: Array<float> = rotate_y(v0, 0.5);
        print("Rotation Result X:");
        print(r[0]);
        print("Rotation Result Y:");
        print(r[1]);
        print("Rotation Result Z:");
        print(r[2]);
        print("Rotation successful.");

        // Run one frame of logic (without SDL rendering)
        print("Running logic frame...");
        let angle_y: float = 0.5;
        let angle_x: float = 0.25;

        let proj_verts: Array<Array<float>> = alloc_array(8);
        let k: int = 0;
        loop (k < 8, 10) {
            let v: Array<float> = verts[k];
            let r1: Array<float> = rotate_y(v, angle_y);
            let r2: Array<float> = rotate_x(r1, angle_x);
            proj_verts[k] = project_vertex(r2, 800, 600);
            k = k + 1;
        }
        print("Logic frame complete.");

        return 0;
    }
}
